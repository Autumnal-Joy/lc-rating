# 单调栈 (MonotoneStack)
[视频讲解](https://www.bilibili.com/video/BV1VN411J7S7/)

## 模板一
找到每个元素的下一个更大元素（Next Greater Element）
> 例题  [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)
```python
def next_greater_element(nums):
    stack = []
    result = [-1] * len(nums)
    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:
            result[stack.pop()] = nums[i] # 这里存的是元素，也可以直接存下标 i
        stack.append(i)
    return result
``` 
##  模板二
找到每个元素的下一个更小元素（Next Smaller Element）
```python
def next_smaller_element(a: List[int]) -> List[int]:
    stack = []
    result = [-1] * len(nums)
    for i in range(len(nums)):
        while stack and nums[i] < nums[stack[-1]]:
            result[stack.pop()] = nums[i] # 这里存的是元素，也可以直接存下标 i
        stack.append(i)
    return result
```

## 模板三
找到每个元素的前一个更大元素（Previous Greater Element）
```python
def previous_greater_element(nums):
    stack = []
    result = [-1] * len(nums)
    for i in range(len(nums)-1, -1, -1):
        while stack and nums[i] > nums[stack[-1]]:
            result[stack.pop()] = nums[i]
        stack.append(i)
    return result
```

## 模板四
找到每个元素的前一个更小元素（Previous Smaller Element）
```python
def previous_smaller_element(nums):
    stack = []
    result = [-1] * len(nums)
    for i in range(len(nums)-1, -1, -1):
        while stack and nums[i] < nums[stack[-1]]:
            result[stack.pop()] = nums[i]
        stack.append(i)
    return result
```
## 模板五
找到每个元素的右侧最小的大于等于当前元素的索引
> 例题  [975. 奇偶跳](https://leetcode.cn/problems/odd-even-jump/description/)
```python
def next_min_larger_element(nums):
    n = len(nums)
    a = sorted(range(n), key=lambda i: nums[i]) # 下标按元素值升序
    result = [None] * n
    st = []
    for i in a:
        while st and st[-1] < i: # i 是 st "最小的更大"
            result[st.pop()] = i
        st.append(i)
    return result
```

## 模板六
找到每个元素的右侧最大的小于等于当前元素的索引
> 例题  [975. 奇偶跳](https://leetcode.cn/problems/odd-even-jump/description/)
```python
def next_max_smaller_element(nums):
    n = len(nums)
    a = sorted(range(n), key=lambda i: -nums[i]) # 下标按元素值降序
    result = [None] * n
    st = []
    for i in a:
        while st and st[-1] < i: # i 是 st "最大的更小"
            result[st.pop()] = i
        st.append(i)
    return result
```

